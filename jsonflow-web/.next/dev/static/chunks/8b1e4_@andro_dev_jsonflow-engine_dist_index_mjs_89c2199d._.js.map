{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Coding/project/json-flow/node_modules/.pnpm/%40andro.dev%2Bjsonflow-engine%401.1.0/node_modules/%40andro.dev/jsonflow-engine/src/schema/graph.ts","file:///D:/Coding/project/json-flow/node_modules/.pnpm/%40andro.dev%2Bjsonflow-engine%401.1.0/node_modules/%40andro.dev/jsonflow-engine/src/semantic.ts","file:///D:/Coding/project/json-flow/node_modules/.pnpm/%40andro.dev%2Bjsonflow-engine%401.1.0/node_modules/%40andro.dev/jsonflow-engine/src/adapter/cytoscape.ts","file:///D:/Coding/project/json-flow/node_modules/.pnpm/%40andro.dev%2Bjsonflow-engine%401.1.0/node_modules/%40andro.dev/jsonflow-engine/src/index.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport const GraphTypeSchema = z.enum([\"graph\", \"sequence\", \"flow\"]);\n\nexport const NodeKindSchema = z.enum([\n  \"actor\",\n  \"lifeline\",\n  \"message\",\n  \"activity\",\n  \"state\",\n  \"class\",\n]);\n\nexport const NodeShapeSchema = z.enum([\n  \"ellipse\",\n  \"rectangle\",\n  \"round-rectangle\",\n  \"diamond\",\n  \"hexagon\",\n  \"triangle\",\n]);\n\nexport const EdgeLinkTypeSchema = z.enum([\n  \"solid\",\n  \"dash\",\n  \"dot\",\n  \"double\",\n  \"bold\",\n  \"arrow\",\n  \"open-arrow\",\n]);\n\nexport const EdgeKindSchema = z.enum([\n  \"next\",\n  \"call\",\n  \"return\",\n  \"async\",\n  \"transition\",\n  \"inherit\",\n  \"association\",\n]);\n\nexport const LayoutDirectionSchema = z.enum([\"LR\", \"RL\", \"TB\", \"BT\"]);\n\nexport const LayoutSchema = z.object({\n  direction: LayoutDirectionSchema.default(\"LR\"),\n});\n\nexport const NodeSchema = z.object({\n  id: z.string(),\n  label: z.string().optional(),\n  type: z.string().optional(),\n  kind: NodeKindSchema.optional(),\n  shape: NodeShapeSchema.optional(),\n  properties: z.record(z.string(), z.unknown()).optional(),\n});\n\nexport const EdgeSchema = z.object({\n  from: z.string(),\n  to: z.string(),\n  label: z.string().optional(),\n  kind: EdgeKindSchema.optional(),\n  link_type: EdgeLinkTypeSchema.optional(),\n});\n\nexport const GraphSchema = z.object({\n  type: GraphTypeSchema.default(\"flow\"),\n  layout: LayoutSchema.optional(),\n  nodes: z.array(NodeSchema),\n  edges: z.array(EdgeSchema),\n});\n","import type { Graph } from \"./types/graph\";\n\nexport type SemanticIssue =\n  | {\n      type: \"edge-missing-node\";\n      edge: { from: string; to: string };\n      missing: string;\n    }\n  | {\n      type: \"unreachable-node\";\n      nodeId: string;\n    };\n\nexport type SemanticMeta = {\n  isCyclic: boolean;\n};\n\nexport type SemanticResult = {\n  meta: SemanticMeta;\n  issues: SemanticIssue[];\n};\n\nconst buildAdjacency = (graph: Graph, nodeIds: Set<string>) => {\n  const adjacency = new Map<string, string[]>();\n  const incoming = new Map<string, number>();\n\n  graph.nodes.forEach((node) => {\n    adjacency.set(node.id, []);\n    incoming.set(node.id, 0);\n  });\n\n  graph.edges.forEach((edge) => {\n    if (!nodeIds.has(edge.from) || !nodeIds.has(edge.to)) {\n      return;\n    }\n    adjacency.get(edge.from)?.push(edge.to);\n    incoming.set(edge.to, (incoming.get(edge.to) ?? 0) + 1);\n  });\n\n  return { adjacency, incoming };\n};\n\nconst detectCycle = (adjacency: Map<string, string[]>) => {\n  const visiting = new Set<string>();\n  const visited = new Set<string>();\n  let isCyclic = false;\n\n  const dfs = (nodeId: string) => {\n    if (isCyclic) return;\n    if (visiting.has(nodeId)) {\n      isCyclic = true;\n      return;\n    }\n    if (visited.has(nodeId)) return;\n\n    visiting.add(nodeId);\n    const neighbors = adjacency.get(nodeId) ?? [];\n    neighbors.forEach(dfs);\n    visiting.delete(nodeId);\n    visited.add(nodeId);\n  };\n\n  Array.from(adjacency.keys()).forEach(dfs);\n  return isCyclic;\n};\n\nconst findUnreachable = (\n  adjacency: Map<string, string[]>,\n  incoming: Map<string, number>,\n) => {\n  const roots = Array.from(incoming.entries())\n    .filter(([, count]) => count === 0)\n    .map(([id]) => id);\n\n  if (roots.length === 0) {\n    return [] as string[];\n  }\n\n  const reachable = new Set<string>();\n  const queue = [...roots];\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current || reachable.has(current)) continue;\n    reachable.add(current);\n    const neighbors = adjacency.get(current) ?? [];\n    neighbors.forEach((next) => {\n      if (!reachable.has(next)) {\n        queue.push(next);\n      }\n    });\n  }\n\n  return Array.from(adjacency.keys()).filter((id) => !reachable.has(id));\n};\n\nexport const analyzeGraph = (graph: Graph): SemanticResult => {\n  const nodeIds = new Set(graph.nodes.map((node) => node.id));\n  const issues: SemanticIssue[] = [];\n\n  graph.edges.forEach((edge) => {\n    if (!nodeIds.has(edge.from)) {\n      issues.push({\n        type: \"edge-missing-node\",\n        edge: { from: edge.from, to: edge.to },\n        missing: edge.from,\n      });\n    }\n    if (!nodeIds.has(edge.to)) {\n      issues.push({\n        type: \"edge-missing-node\",\n        edge: { from: edge.from, to: edge.to },\n        missing: edge.to,\n      });\n    }\n  });\n\n  const { adjacency, incoming } = buildAdjacency(graph, nodeIds);\n  const isCyclic = detectCycle(adjacency);\n\n  const unreachable = findUnreachable(adjacency, incoming);\n  unreachable.forEach((nodeId) => {\n    issues.push({ type: \"unreachable-node\", nodeId });\n  });\n\n  return {\n    meta: { isCyclic },\n    issues,\n  };\n};\n","import type { EngineGraph } from \"../types/graph\";\n\nexport type CytoscapeNode = {\n  data: {\n    id: string;\n    label?: string;\n    type?: string;\n    kind?: string;\n    shape?: string;\n    properties?: Record<string, unknown>;\n  };\n};\n\nexport type CytoscapeEdge = {\n  data: {\n    id: string;\n    source: string;\n    target: string;\n    label?: string;\n    kind?: string;\n    link_type?: string;\n  };\n};\n\nexport type CytoscapeGraph = {\n  nodes: CytoscapeNode[];\n  edges: CytoscapeEdge[];\n};\n\nexport const toCytoscape = (graph: EngineGraph): CytoscapeGraph => {\n  const nodes = graph.nodes.map((node) => {\n    const data: {\n      id: string;\n      label?: string;\n      type?: string;\n      kind?: string;\n      shape?: string;\n      properties?: Record<string, unknown>;\n    } = {\n      id: node.id,\n    };\n\n    if (node.label !== undefined) {\n      data.label = node.label;\n    }\n    if (node.type !== undefined) {\n      data.type = node.type;\n    }\n    if (node.kind !== undefined) {\n      data.kind = node.kind;\n    }\n    if (node.shape !== undefined) {\n      data.shape = node.shape;\n    }\n    if (node.properties !== undefined) {\n      data.properties = node.properties;\n    }\n\n    return { data };\n  });\n\n  const edges = graph.edges.map((edge) => {\n    const data: {\n      id: string;\n      source: string;\n      target: string;\n      label?: string;\n      kind?: string;\n      link_type?: string;\n    } = {\n      id: `${edge.from}->${edge.to}`,\n      source: edge.from,\n      target: edge.to,\n    };\n\n    if (edge.label !== undefined) {\n      data.label = edge.label;\n    }\n    if (edge.kind !== undefined) {\n      data.kind = edge.kind;\n    }\n    if (edge.link_type !== undefined) {\n      data.link_type = edge.link_type;\n    }\n\n    return { data };\n  });\n\n  return { nodes, edges };\n};\n","import { z } from \"zod\";\nimport { EdgeSchema, GraphSchema, NodeSchema } from \"./schema/graph\";\nimport type {\n  Edge,\n  EngineGraph,\n  Graph,\n  Node,\n} from \"./types/graph\";\nimport { analyzeGraph, type SemanticIssue, type SemanticMeta } from \"./semantic\";\n\nexport type EngineResult =\n  | {\n      ok: true;\n      graph: Graph;\n      engineGraph: EngineGraph;\n      meta: SemanticMeta;\n      semantic: SemanticIssue[];\n    }\n  | { ok: false; error: z.ZodError };\n\nexport class Engine {\n  validate(input: unknown): Graph {\n    return GraphSchema.parse(input);\n  }\n\n  safeValidate(input: unknown): ReturnType<typeof GraphSchema.safeParse> {\n    return GraphSchema.safeParse(input);\n  }\n\n  parse(input: unknown): EngineResult {\n    const result = GraphSchema.safeParse(input);\n    if (!result.success) {\n      return { ok: false, error: result.error };\n    }\n\n    const graph = result.data;\n    const engineGraph: EngineGraph = {\n      nodes: graph.nodes,\n      edges: graph.edges,\n    };\n    const semantic = analyzeGraph(graph);\n\n    return {\n      ok: true,\n      graph,\n      engineGraph,\n      meta: semantic.meta,\n      semantic: semantic.issues,\n    };\n  }\n}\n\nexport {\n  EdgeSchema,\n  GraphSchema,\n  NodeSchema,\n};\n\nexport { toCytoscape } from \"./adapter/cytoscape\";\n"],"names":[],"mappings":"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"}}]
}